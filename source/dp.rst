Динамическое программирование
"""""""""""""""""""""""""""""

НВП - наибольшая возрастающая подпоследоватеьность

:math:`i < j < n ... < k`

:math:`a_i < a_j ... a_k`


Используя дерево отрезков на максимум :math:`O(n \log n)`
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Сожмём массив a

#. sort(a)

#. TODO


b[x] = НВП окончивающийся элементом x

.. code-block:: python

    for i in range(n):
        dp[i] = b.get(0, a[i] - 1) + 1
        b.relax(a[i], dp)




:math:`O(n ^ 2)`
""""""""""""""""

#. :math:`d[i]` - наименьшее число на которое заканчивается НВП размером i

#. Изначально мы полагаем :math:`d[0] = -\infty`, а все остальные элементы :math:`d[i] = \infty`.

#. Считать эту динамику мы будем постепенно, обработав число :math:`a[0]`, затем :math:`a[1]`, и т.д.

Приведём реализацию этой динамики за :math:`O (n^2)`:

TODO code-
""""""""""

.. code-block:: text

    int d[MAXN];
    d[0] = -INF;
    for (int i=1; i<=n; ++i)
        d[i] = INF;

    for (int i=0; i<n; i++)
        for (int j=1; j<=n; j++)
            if (d[j-1] < a[i] && a[i] < d[j])
                d[j] = a[i];

Используя бинпоиск :math:`O(n \log n)`
""""""""""""""""""""""""""""""""""""""

Используя функцию :math:`upper_bound`  (который возвращает позицию первого элемента, строго большего данного):

.. code-block:: cpp

    #include <bits/stdc++.h>

    using namespace std;

    #define ll long long
    #define INF (long long) 1e18

    int main() {
        ll n, t;
        cin >> n;
        vector<ll> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        vector<ll> d (n + 1, INF);
        d[0] = -INF;
        vector<ll> p (n);
        vector<ll> no (n + 1);
        no[0] = -1;
        for (ll i = 0; i < n; i++) {
                ll j = upper_bound(d.begin(), d.end(), a[i]) - d.begin() - 1;
                if (d[j] < a[i] && a[i] < d[j + 1]) {
                        d[j + 1] = a[i];
                        p[i] = no[j];
                        no[j + 1] = i;
                }
        }
        vector<int> result;
        for (int i = n; i >= 1; i--)
            if (d[i] != INF) {
                for (int cur = no[i]; cur != -1; cur = p[cur])
                    result.push_back (cur);
                    break;
                }
        reverse(result.begin(), result.end());
        cout << result.size() << "\n";
        for (unsigned i = 0; i < result.size(); i++)
                cout << result[i] + 1 << " ";
        return 0;
    }

___________________________


НОП
"""

НОП - наибольшая общая подпоследовательность

Последовательность :math:`Z=⟨z_1,z_2,…,z_k⟩` является подпоследовательностью (англ. subsequence) последовательности :math:`X=⟨x_1,x_2,…,x_m⟩`, если существует строго возрастающая последовательность :math:`⟨i_1,i_2,…,i_k⟩` индексов :math:`X` таких, что для всех :math:`j=1,2,…,k` выполняется соотношение :math:`x_{i_j}=z_j`.

Задача:

Пусть имеются последовательности :math:`X=⟨x_1,x_2,…,x_m⟩` и :math:`Y=⟨y_1,y_2,…,y_n⟩`. Необходимо найти :math:`LCS(X,Y)`

_________________________________

Рюкзак
""""""

Дано :math:`N` предметов, :math:`W` — вместимость рюкзака, :math:`w={w_1,w_2,…,w_N}` — соответствующий ему набор положительных целых весов, :math:`p={p_1,p_2,…,p_N}` — соответствующий ему набор положительных целых стоимостей.
Нужно найти набор бинарных величин :math:`B={b_1,b_2,…,b_N}`, где :math:`b_i=1`, если предмет :math:`n_i` включен в набор, :math:`b_i=0`, если предмет :math:`n_i` не включен, и такой что:

#. :math:`b_1w_1+⋯+b_Nw_N⩽W`

#. :math:`b_1p_1+⋯+b_Np_N` максимальна.

Динамического программирования. :math:`O(NW)`
"""""""""""""""""""""""""""""""""""""""""""""


TODO https://neerc.ifmo.ru/wiki/index.php?title=Задача_о_рюкзаке


ДП на подотрезках
"""""""""""""""""

строка s PHOTO TODO

Треангуляция
""""""""""""

n - вершин многоугольника. Разбить его на треугольники.

#. Сумма отрезков треугольника минимальна

#. Отрезки не пересекаются

Решение

#. dp[i][j] - цена минимальной треангуляции многоугольника от i до j


Дп по числам
""""""""""""

числа длинной n, суммa цифр k

#. dp[i][j] - кол-во чисел с суммой цифр j и длинной i

PHOTO TODO