Дерево Фенвика
""""""""""""""""

Дерево Фенвика - это структура данных, дерево на массиве, обладающее следующими свойствами:

#. позволяет вычислять значение некоторой обратимой операции :math:`G` на любом отрезке :math:`[L; R]` за время :math:`O(log(n)`;

#. позволяет изменять значение любого элемента за :math:`O(log(n)`;

#. требует :math:`O(n)` памяти, а точнее, ровно столько же, сколько и массив из :math:`O(n)` элементов;

#. легко обобщается на случай многомерных массивов.

Наиболее распространённое применение дерева Фенвика - для вычисления суммы на отрезке, т.е. функция :math:`G (X1, ..., Xk) = X1 + ... + Xk`.

Дерево Фенвика было впервые описано в статье "A new data structure for cumulative frequency tables" (Peter M. Fenwick, 1994).

Описание
""""""""""

Для простоты описания мы предполагаем, что операция :math:`G`, по которой мы строим дерево, - это сумма.

Пусть дан массив :math:`a[0..N-1]`. Дерево Фенвика - массив :math:`T[0..N-1]`, в каждом элементе которого хранится сумма некоторых элементов массива :math:`a`:

:math:`T_i` = сумма :math:`A_j` для всех :math:`F(i) <= j <= i`,
где :math:`F(i)` - некоторая функция, которую мы определим несколько позже.

Теперь мы уже можем написать псевдокод для функции вычисления суммы на отрезке :math:`[0; R]` и для функции изменения ячейки:


.. code-block:: text
   
   int f(int x) {
      return x & (x + 1);
   }

   int h(int x) {
       return x | (x + 1);
   }

   ll sum(int index) {
      ll result = 0;
      while (index >= 0) {
         result += fenwick[index];
         index = f(index) - 1;
      }
      return result;
   }
   
   void edit(int index, ll element) {
      int a_index = index;
      while (index < fenwick.size()) {
         fenwick[index] += (element - a[a_index]);
         index = h(index);
      }  
   }


Функция :math:`sum` работает следующим образом. Вместо того чтобы идти по всем элементам массива :math:`a`, она движется по массиву :math:`t`, делая "прыжки" через отрезки там, где это возможно. Сначала она прибавляет к ответу значение суммы на отрезке :math:`[F(R); R]`, затем берёт сумму на отрезке :math:`[F(F(R)-1); F(R)-1]`, и так далее, пока не дойдёт до нуля.

Функция :math:`inc` движется в обратную сторону - в сторону увеличения индексов, обновляя значения суммы :math:`T_j` только для тех позиций, для которых это нужно, т.е. для всех :math:`j` для которых :math:`F(j) <= i <= j`.

Очевидно, что от выбора функции :math:`F` будет зависеть скорость выполнения обеих операций. Сейчас мы рассмотрим функцию, которая позволит достичь логарифмической производительности в обоих случаях.

Определим значение :math:`F(X)` следующим образом. Рассмотрим двоичную запись этого числа и посмотрим на его младший бит. Если он равен нулю, то :math:`F(X) = X`. Иначе двоичное представление числа :math:`X` оканчивается на группу из одной или нескольких единиц. Заменим все единицы из этой группы на нули, и присвоим полученное число значению функции :math:`F(X)`.

Этому довольно сложному описанию соответствует очень простая формула:
.. math::

   F(X) = X & (X+1)

где :math:`\&` - это операция побитового логического "И".

Нетрудно убедиться, что эта формула соответствует словесному описанию функции, данному выше.

Нам осталось только научиться быстро находить такие числа :math:`j`, для которых :math:`F(j) <= i <= j`.

Однако нетрудно убедиться в том, что все такие числа :math:`j`получаются из :math:`i` последовательными заменами самого правого (самого младшего) нуля в двоичном представлении. Например, для :math:`i = 10` мы получим, что :math:`j = 11, 15, 31, 63` и т.д.

Как ни странно, такой операции (замена самого младшего нуля на единицу) также соответствует очень простая формула:

.. math::
   H(X) = X | (X+1)

где :math:`|` - это операция побитового логического "ИЛИ".
